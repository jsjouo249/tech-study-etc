OPTIMIZER (옵티마이저)
효율적이고 빠른 SQL 실행 계획을 위한 DBMS내의 핵심엔진

최적의 실행방법을 결정하는 역할

규칙 기반 옵티마이저 / 비용 기반 옵티마이저

1.규칙 기반 옵티마이저 - heuristic 옵티마이저
미리 정해 놓은 규칙에 따라 엑세스 경로를 평가하고 실행계획 실행
ㄴ 규칙 : 액세스 경로별 우선순위로, 인덱스의 구조, 연산자, 조건절

2.비용기반 옵티마이저
예상되는 비용(소요되는 일량 또는 시간)을 기반으로 최적화를 수행 - 테이블과 인덱스에 대한 통계정보를 기초로 각 단계별 예상 비용 산정 후, 가장 적은 비용의 계획 선택
ㄴ 통계 정보 : 레코드 개수, 블록 개수, 행 길이, 컬럼 값의 수/분포, 인덱스 높이, 시스템 정보 등

SQL 최적화 과정
1. Parser			: SQL문장의 개별 구성요소를 분석하고 파싱해서 파싱 트리를 만듬.
2. Query Transformer	: 파싱된 SQL을 효율적으로 실행하기 위해 일반적이고 표준적인 형태로 변환
3. Estimator		: 통계 정보를 이용하여 SQL 실행 비용을 계산
4. Plan Generator		: SQL 실행 계획들을 수립
5. Row-Source Generator	: 실행계획을 엔진이 실행시킬 수 있는 코드 형태로 변환
6. SQL Engine		: SQL 실행

실행 계획 줄이기.

조인
NL JOIN(중첩 루프 조인) - 선행 테이블의 조건을 만족하는 행으로 후행 테이블을 읽으면서 조인 수행.
조건에 만족하는 선행 테이블의 행의 수 만큼 수행하기 때문에, 행의 수가 적은 테이블을 선행 테이블로 사용
랜덤 방식으로 데이터를 액세스 하기 떄문에, 처리 범위가 좁은 것을 조건으로 선택
메모리가 필요없는 조인 방법으로 추가적인 메모리 비용이 필요치 않음.

SORT MERGE JOIN - 조인 컬럼을 기준으로 데이터 정렬 후 조인 수행.
넓은 범위의 데이터를 처리할 때 이용
정렬을 해야 하기 때문에, 성능이 떨어질 수 있음.
HASH JOIN과 다르게 비동등 조인도 작업이 가능. ( >, >=, <, <= )
스캔 방식으로 데이터를 읽음

HASH JOIN- 조인을 수행할 테이블의 조인컬럼을 기준으로 해쉬 함수 수행하여 동일한 해쉬 값을 갖는 것들 사이에서  실제 값이 같은지 비교하며 조인 수행.
NL JOIN의 랜덤 액세스, SORT MERGE JOIN의 정렬의 작업 부담 해결하기 위한 대안
조인 칼럼의 인덱스가 없어도 사용 가능.
해쉬 함수를 이용하기 때문에, =을 사용하는 동등조건에만 ㅏ용 가능.
메모리에 해쉬 테이블을 따로 생성해야 함.
메모리에 적재할 수 있는 용량보다 커지면, 디스크에 해쉬 테이블을 저장
반환되는 ROW수가 적은 테이블과, 반환되는 ROW수가 많은 테이블 조인시 유리

힌트
잘못된 실행계획을 수정할 때 개발자가 힌트를 사용하여, 실행 계획을 수정.

인덱스
일종의 색인기술로 검색 성능의 최적화.
pk는 자동으로 인덱스 생성
너무 많은 인덱스는 db에 부하 발생
오름차순, 내림차순 설정 가능
컬럼의 순서가 검색에 영향을 끼침.

index scan
1. 인덱스 유일 스캔
=로 검색 시 가능한 방식으로, 조건절이 =이기 때문에, 단 하나의 데이터를 추출

2. 인덱스 범위 스캔
한 건 이상의 데이터를 추출하는 방식

! 인덱스 활용이 불가능한 경우 !
LIKE 검색 시, 좌변에 % 붙이는 경우
인덱스가 걸려있는 컬럼을 변형하는 경우
NULL 비교
부정형 비교